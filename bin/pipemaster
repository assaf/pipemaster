#!/this/will/be/overwritten/or/wrapped/anyways/do/not/worry/ruby
# -*- encoding: binary -*-
require "pipemaster"
require "optparse"

ENV["RACK_ENV"] ||= "development"
server = false
daemonize = false
listeners = []
options = { :listeners => listeners }
host, port = Pipemaster::DEFAULT_HOST, Pipemaster::DEFAULT_PORT

opts = OptionParser.new("", 24, '  ') do |opts|
  opts.banner = "Usage: #{File.basename($0)}\n" \
                "[ruby options] [pipemaster options] command [args]\n" \
                "[ruby options] [pipemaster options] --server [Pipefile]"

  opts.separator "Ruby options:"

  lineno = 1
  opts.on("-e", "--eval LINE", "evaluate a LINE of code") do |line|
    eval line, TOPLEVEL_BINDING, "-e", lineno
    lineno += 1
  end

  opts.on("-d", "--debug", "set debugging flags (set $DEBUG to true)") do
    $DEBUG = true
  end

  opts.on("-w", "--warn", "turn warnings on for your script") do
    $-w = true
  end

  opts.on("-I", "--include PATH",
          "specify $LOAD_PATH (may be used more than once)") do |path|
    $LOAD_PATH.unshift(*path.split(/:/))
  end

  opts.on("-r", "--require LIBRARY",
          "require the library, before executing your script") do |library|
    require library
  end

  opts.separator "Pipemaster options:"

  opts.on("-s", "--socket {HOST:PORT|PATH}",
          "communicate on HOST:PORT or PATH",
          "for server, this may be specified multiple times",
          "(default: #{Pipemaster::DEFAULT_LISTEN})") do |address|
    listeners << address
  end

  opts.on("-E", "--env ENVIRONMENT",
          "use ENVIRONMENT for defaults (default: development)") do |e|
    ENV["PIPE_ENV"] = e
  end

  opts.on("-S", "--server", "run as server (default: client)") do |s|
    server = s ? true : false
  end

  opts.on("-D", "--daemonize", "run daemonized in the background") do |d|
    daemonize = d ? true : false
  end

  opts.separator "Common options:"

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts.to_s.gsub(/^.*DEPRECATED.*$/s, '')
    exit
  end

  opts.on_tail("-v", "--version", "Show version") do
    puts "Pipemaster v#{Pipemaster::VERSION}"
    exit
  end

  opts.parse! ARGV
end

if server

  config = ARGV[0] || "Pipefile"
  abort "configuration file #{config} not found" unless File.exist?(config)
  options[:config_file] = config
  Dir.chdir File.dirname(config)
  Unicorn::Launcher.daemonize!(options) if daemonize
  Pipemaster.run(options)

else
  BUFFER_SIZE = 4000

  socket = TCPSocket.new("127.0.0.1", 7887)
  socket.sync = true
  args = ARGV.join("\0")
  socket << [args.size].pack("N") << args
  socket.flush
  stdinbuf, stdoutbuf = ' ' * BUFFER_SIZE, nil
  unless $stdin.isatty
    while selected = select([$stdin, socket])
      begin
        if selected.first.include?($stdin)
          $stdin.readpartial(BUFFER_SIZE, stdinbuf)
          socket.write stdinbuf
        elsif selected.first.include?(socket)
          exit 1 if socket.eof?
          $stdout.write stdoutbuf if stdoutbuf
          stdoutbuf = socket.readpartial(BUFFER_SIZE)
        end
      rescue EOFError
        break
      end
    end
  end
  socket.close_write
  while selected = select([socket])
    break if socket.eof?
    $stdout.write stdoutbuf if stdoutbuf
    stdoutbuf = socket.readpartial(BUFFER_SIZE)
  end
  if stdoutbuf
    status = stdoutbuf[-1]
    $stdout.write stdoutbuf[0..-2]
    exit status.ord
  else
    exit 1
  end
end
